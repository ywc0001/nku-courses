## 面向结构
特点: 自顶向下；逐步求精；模块化设计；结构化编码

组成：**数据，函数，流程**
优点：易于阅读、理解、测试和维护
缺点：可扩展性差；项目管理复杂；灵活性差；代码重复率高

## 面向对象

组成：**类，用例图，关联图**
优点：可重用性、可读性、可扩展性好
缺点：运行性能差；类库复杂；入门难度高；可靠性差

### 类的定义与关系
组成：名称，属性（数据），方法（函数）
**类和类的关系：继承，依赖，组合，关联，聚合，实现**

- 继承：一个类继承另一个类的功能，并可以增加自己的新功能；
- 依赖：一个类使用到了另一个类的功能，但这种使用关系具有偶然性，是临时的、非常弱的；
- 聚合：两个类之间存在整体与部分的关系，即一个对象包含另一个对象，部分可以离开整体而单独存在；
- 组合：也是整体与部分的关系，但是二者具有统一的生存期，也就是整体消失，部分不复存在，组合关系相较于聚合更强，因为部分的生命周期依赖于整体的生命周期；
- 关联：两个类之间存在结构化的关系，一个类的对象可访问另一个类的相关对象；
- 实现：一个类实现接口的功能，通过关键词implement标识。

### 用例图
定义：由**参与者（Actor），用例（Use case）和它们之间的关系**构成的用于描述系统功能的动态视图。
参与者：人（用户），系统，子系统和外部实体

绘制方式：要显示用例--绘制椭圆，将用例的名字放在椭圆的中心或下方的中间位置；要绘制参与者--绘制一个人形符号；显示参与者与用例之间的关系--用带箭头或不带箭头的线段，箭头表明这一关系中哪一方是对话的主动发起者，所指方是对话的被动接受者。

### 状态图
定义：状态图（State Chart）用于描述一个实体基于事件反应的动态行为，显示了该实体在面对不同的事件时，如何根据当前所处的状态做出反应。
**研究目的：类、子系统、角色、组件的复杂行为**

状态--对象执行某项活动或等待某个事件时的条件；对象可能会在有限的时间长度内保持某一状态。

**状态的特征**
- 名称：将一个状态和另一个状态区分开来的文本字符串；状态也可能是匿名的，这表示它没有名称；
- 进入/退出操作：在进入和退出状态时执行的操作；
- 内部转移：在不使状态发生变更的情况下进行的转移；
- 子状态：状态的嵌套结构，包括不相连的（依次处于活动状态）和并行的（同时处于活动状态）子状态；
- 延迟的事件：未被该状态中处理，但被延迟处理的一系列事件（即列队等待，由另一个状态的对象来处理）

**状态转移**
定义：状态转移是两个状态之间的关系，它指的是发生指定时间并满足指定条件时，第一个状态中的对象将执行某些操作并将进入第二个状态。当发生这种状态变更时，即触发了转移。在触发转移之前，可认为对象处于“源”状态，在触发转移之后，可认为对象处于“目标”状态。

特征：
- 源状态：转移所影响的状态。当对象收到转移的触发事件并满足警戒条件时（如果有），就可能触发输出转移；
- 事件触发器：使转移满足触发条件的事件。当处于源状态的对象收到该事件时（假设已满足警戒条件），就可能会触发转移；
- 警戒条件：一种布尔表达式。当接受到事件触发器并触发转移时，将对该表达式求值。如果求值结果为True，说明转移符合触发条件；如果求值结果为False，则不触发转移。如果没有其他转移可以由同一事件来触发，该事件就将被丢弃。
- 操作：可执行的、不可分割的计算过程。该计算可能直接作用于拥有状态机的对象，也可能间接作用于该对象可见的其他对象。
- 目标状态：在完成转移后被激活的状态。



### 顺序图
也叫做序列图，时序图，用于描述系统功能的各个不同角色之间相互协作、传递消息的顺序关系。

顺序图是按时间顺序显示对象交互的图。具体来说，它显示了参与交互的对象和所交换信息的先后顺序，用来表示用例中的行为，并将这些行为建模成信息交换。

顺序图主要包括四个因素：**对象(Obejct)，生命线（Lifeline），激活（activation），消息（message）**。其中纵向代表时间维度，时间向下延伸，按时间依次列出各个对象所发出和接收的消息。横向代表对象的维度，排列着参与交互的各个独立的对象。一般主要参与者放左边，次要参与者放在最右边。


### 设计模式类型
#### 创建型模式
- Singleton：单例模式（全局只需要一个实例）
- Prototype：原型模式（通过拷贝原对象创建新对象）
- Factory Method:工厂方法模式（对象创建可控，隐藏具体类名等实现解耦）
- Abstract Factory: 抽象工厂模式（解决对象与其属性匹配的工厂模式）
- Builder: 建造者模式（封装降低耦合，生成的对象与构造顺序无关）

这五种模式有各自的使用环境，单例和原型比较简单。工厂方法模式和建造者模式，都是封装和降低耦合，工厂方法关注的是一个类有多个子类的对象创建（汽车类的各种品牌），而建造者模式关注的是属性较多的对象创建（能达到过程无关）。而抽象工厂模式关注的是对象和属性以及属性与属性的匹配关系（如奥迪汽车与发动机及空调的匹配）。

#### 结构型模式（对象的组成以及对象之间的依赖关系）
- Adapter：适配器模式(适配不同接口和类，一般解决历史遗留问题)
- Decorator:装饰器模式(比继承更加灵活，可用排列组成形成多种扩展类)
- Proxy: 代理模式（可以给类的每个方法增加逻辑，如身份验证）
- Facade: 外观模式（对模块或产品的封装，降低耦合）
- Bridge: 桥接模式（就是接口模式，抽象和实现分离）
- Plyweight: 享元模式（相同对象的重用）
- Composite: 组合模式（整体与部分相同时，如文件包含文件夹）

适配器模式、装饰器模式和代理模式都可以用封装对象实现（把对象作为一个属性放在用的对象里），所以模式关注的不是实现，而是解决的问题。模式更多体现的是类与类之间的逻辑关系，比如代理模式和装饰器模式很像，但从字面就知道，代理是访问不了实际工作对象的，这是他们之间的区别。

#### 行为型模式（对象的组成以及对象之间的依赖关系）
- Strategy: 策略模式（提供功能不同实现方式，且实现可选）
- Template Method: 模版方法模式（相同流程都用同一个模版方法）
- Observer: 观察者模式（用订阅-发布实现的被观察者变化时回调）
- Iterator: 迭代器模式（一种内部实现无关的集合遍历模式）
- Chain of Responsibility: 责任链模式（事件处理的分层结构产生的责任链条）
- Command: 命令模式（将命令者与被命令者分离）
- Memento: 备忘录模式（需要撤销和恢复操作时使用）
- State: 状态模式（当对象两种状态差别很大时使用）
- Visitor: 访问者模式（当对同一对象有多种不同操作时使用）
- Mediator: 中介者模式（以中介为中心，将网状关系变为星型关系）
- Interpreter:解释器模式（常用于纯文本的表达式执行）

**设计模式用途**
- 可重用代码
- 可复用设计
- 保证代码可靠性
- 提高设计灵活性
- 缩短设计和编程时间

**设计模式属性**
- 可重用性
- 可读性
- 可靠性
- 可扩展性
- 普适性


#### 一些设计模式
##### 外观模式

外观模式是一种结构型设计模式，它提供了一个简单的接口，用于访问复杂系统的一组接口。它将系统的复杂性隐藏在一个单独的外观类中，使客户端代码更加简洁和易于使用。外观模式的核心思想是将**系统的各个部分解耦**，使它们能够独立地变化。客户端只需要与外观类交互，而不需要了解系统的内部实现。外观模式通常用于**简化大型系统的接口**，以及隐藏系统的复杂性。在外观模式中，通常会定义一个外观类，它包含一组简单的方法，用于访问系统的各个部分。这些方法可以将客户端请求转发给系统的不同部分，并返回结果。

外观模式的结构包括以下几个部分：外观类（Facade）：外观类是外观模式的核心，它提供了一个简单的接口，用于访问系统的一组接口。外观类通常包含一组简单的方法，用于将客户端请求转发给系统的不同部分，并返回结果。子系统类（Subsystem）：子系统类是系统的各个部分，它们实现了系统的各种功能。子系统类可以是一个或多个类，它们之间可能存在依赖关系。客户端（Client）：客户端是使用外观模式的代码，它通过外观类访问系统的各个部分。客户端不需要了解系统的内部实现，只需要与外观类交互即可。


##### 桥接模式

桥接模式（Bridge Pattern） 也称为桥梁模式、接口模式或者柄体模式，是将抽象部分与它的具体实现部分分离，使它们都可以独立地变化，属于结构型模式。桥接模式主要目的是**通过组合的方式建立两个类之间的联系**，而不是继承。但又类似于多重继承方案，但是多重继承方案往往违背了类的单一职责原则，其复用性较差，桥接模式是比多重继承更好的替代方案。桥接模式的核心在于**解耦抽象和实现**。

桥接模式的结构包括以下几个部分：

抽象（Abstraction）： 该类持有一个对实现角色的引用，抽象角色中的方法需要实现角色来实现，抽象角色一般为抽象类（构造函数规定子类要传入一个实现对象）；
修正抽象（Refined Abstraction）： Abstraction的具体实现，对Abstraction的方法进行完善和扩展；
实现（Implementor）： 确定实现维度的基本操作，提供给Abstraction使用。该类一般为接口或者抽象类；
具体实现（Concrete Implementor）： Implementor的具体实现；


##### 适配器

适配器（Adapter)，将一个类的接口转换成客户希望的另一个接口，**使得原本不兼容的接口能一起工作**。比如，你有一个台灯的充电线式两孔的插头，而现在只有一个插座是三孔的，此时你可能就需要一个给这个三孔插座接一个插板，这个插板上就有 两孔的、三孔的....  这样你的台灯就能用了。

适配器模式包含以下主要角色：
目标接口：当前客户所期待的接口，它可以是抽象类或者接口（上述的 两孔插座）
适配者类：是被访问的现存组件库中的接口（上述的 两孔插头）
适配器类：是一个转换器，通过继承或引用目标接口，实现适配者类的所有方法，就可以实现转换效果

##### 装饰器模式

装饰器模式（Decorator Pattern） 也称为包装模式(Wrapper Pattern) 是指在**不改变原有对象的基础**之上，将功能附加到对象上，提供了比继承更有弹性的替代方案(扩展原有对象的功能)，属于结构型模式。装饰器模式的核心是**功能扩展**，使用装饰器模式可以透明且动态地扩展类的功能。

装饰器模式包含以下主要组成部分：
抽象组件（Component）： 可以是一个接口或者抽象类，其充当被装饰类的原始对象，规定了被装饰对象的行为；
具体组件（ConcreteComponent）： 实现/继承Component的一个具体对象，也即被装饰对象；
抽象装饰器（Decorator）： 通用的装饰ConcreteComponent的装饰器，其内部必然有一个属性指向Component抽象组件；其实现一般是一个抽象类，主要是为了让其子类按照其构造形式传入一个Component抽象组件，这是强制的通用行为（当然，如果系统中逻辑单一，并不需要实现许多装饰器，那么我们可以直接省略该类，而直接实现一个具体装饰器（ComcreteDecorator）即可）；
具体装饰器（ConcreteDecorator）： Decorator的具体实现类，理论上，每个ConcreteDecorator都扩展了Component对象的一种功能；

##### 桥接模式

桥接模式（Bridge Pattern） 也称为桥梁模式、接口模式或者柄体模式，是将**抽象部分与它的具体实现部分分离**，使它们都可以独立地变化，属于结构型模式。桥接模式主要目的是通过组合的方式建立两个类之间的联系，而不是继承。但又类似于多重继承方案，但是多重继承方案往往违背了类的单一职责原则，其复用性较差，桥接模式是比多重继承更好的替代方案。桥接模式的核心在于解耦抽象和实现。

桥接模式的结构包括以下几个部分：

抽象（Abstraction）： 该类持有一个对实现角色的引用，抽象角色中的方法需要实现角色来实现，抽象角色一般为抽象类（构造函数规定子类要传入一个实现对象）；
修正抽象（Refined Abstraction）： Abstraction的具体实现，对Abstraction的方法进行完善和扩展；
实现（Implementor）： 确定实现维度的基本操作，提供给Abstraction使用。该类一般为接口或者抽象类；
具体实现（ConcreteImplementor）： Implementor的具体实现；

##### 观察者模式

观察者模式（Observer Pattern）是一种行为型设计模式，它定义了一种一对多的依赖关系，让**多个观察者对象同时监听某一个主题对象**。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

观察者模式包含以下角色：主题（Subject）：被观察的对象，维护一个观察者列表，提供添加、删除和通知观察者的方法。观察者（Observer）：观察主题对象的状态变化，实现 Update 方法来更新自己的状态。具体主题（ConcreteSubject）：继承自抽象主题，实现具体业务逻辑。具体观察者（ConcreteObserver）：继承自抽象观察者，实现具体业务逻辑。使用观察者模式可以使得系统更加灵活、可扩展，减少各个模块之间的耦合度。


##### 访问者模式

访问者模式是一种行为型设计模式，它将**数据结构与数据操作分离**，使得在不改变数据结构的前提下可以定义作用于这些元素的新的操作。该模式主要针对系统中拥有固定类型数的对象结构，在其内提供一个accept()方法来接受访问者对象的访问。不同的访问者对同一个元素的访问内容是不同的，使得相同的元素集合可以产生不同的数据结果。总的来说，访问者模式适用于数据结构相对稳定，而操作易于变化的情况。

访问者模式涉及到的角色如下：抽象访问者(Visitor)角色：声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。具体访问者(ConcreteVisitor)角色：实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。抽象节点(Node)角色：声明一个接受操作，接受一个访问者对象作为一个参数。具体节点(ConcreteNode)角色：实现了抽象节点所规定的接受操作。结构对象(ObjectStructure)角色：有如下的责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。


##### 代理模式

代理模式（Proxy Pattern）是设计模式中的一种结构型模式。它为其他对象提供一种代理以**控制对这个对象的访问**。主要用于在不修改原有代码的情况下，通过引入代理类来间接访问目标对象。

代理模式包含如下三个角色：
Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。
Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。
RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。


##### 单例模式

单例模式，属于创建类型的一种常用的软件设计模式。通过单例模式的方法创建的类在当前进程中**只有一个实例**（根据需要，也有可能一个线程中属于单例，如：仅线程上下文内使用同一个实例）。

单例模式包含以下几个主要角色：
单例类：包含单例实例的类，通常将构造函数声明为私有。
静态成员变量：用于存储单例实例的静态成员变量。
获取实例方法：静态方法，用于获取单例实例。
私有构造函数：防止外部直接实例化单例类。
线程安全处理：确保在多线程环境下单例实例的创建是安全的。


##### 迭代器模式

迭代器模式是一种设计模式，它用于提供一种方法来访问一个容器对象中的各个元素，而又不暴露该对象的内部表示。在迭代器模式中，我们定义一个抽象的迭代器类，它包含两个方法：一个是hasNext()方法，用于判断是否还有下一个元素；另一个是next()方法，用于获取下一个元素。然后，每个容器类都实现自己的迭代器类，以访问容器中的元素。

二叉树是一种重要的数据结构，其遍历方式分为：深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即就是层次遍历。前序（根节点---左子树---右子树），中序（左子树---根节点---右子树），后序（左子树---右子树---根节点）。
