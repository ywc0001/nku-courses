# 算法导论
>**2024春期末考题回忆**
>- 程序题：矩阵快速幂；斐波那契数列的记忆化搜索解法；一个数列中第K小的数，要求时间复杂度为O（n）
>- 简答题：主定理公式以及各个参数意义，$log_b a$和d进行比较的意义；a的n次幂的前K项和的递推（要求时间复杂度为$n^3\log {n}$）。
>- 选择题：当代计算机一秒内执行$10^8$条基本语句；双向广度优先搜索是哪个级别的优化（算法）；快速排序有多少种输入，达到$n^2$复杂度的输入有几种；状态变量可以是？；在开关灯游戏中，多少种状态？


**复习总结：**
>  - 当代计算机一秒内可执行$10^8$条基本语句。
>    
>  - 算法的时间复杂度是一个函数，修饰一段代码或算法，由问题的输入规模确定，也即执行的基本语句数。（输入规模为问题自变量，从严谨的角度来看，问题的输入规模由输入数据的内存规模来定义，而非由一个值来定义）
> O：关注重要部分；保留增长最快的部分。（O是时间复杂度记号）   
> 常见的大O运行时间：
>  O($log n$)，对数时间，如二分查找
> O(n)，线性时间，如简单查找 
> O($n*log n$)，如快速排序 
> O($n^2$)，如选择排序 O(n!)，如旅行商问题
> 
> - 算法的判定问题：判断一个问题的解是否存在；优化问题：找到问题的最优解。面对一个问题，先判断是判别问题还是优化问题，然后找到解空间：什么是可行解，最优解？
> 
> - 状态是对可计算问题的一种建模；状态转移是状态通过操作变成另一个状态；状态变量是状态变化的不同取值表示；价值函数，用以衡量当前状态的一个状态到值的映射，该值会伴随着状态转移而更新，该值可以是：布尔值、整数、实数等。
> 状态空间是一个图，不是由点和边组成，是由状态和状态转移组成。
> 
> - 解决问题的四个层次——问题，模型，算法，代码。时间复杂度与问题规模与基本语句有关，是修饰算法级别的量。 
> 快速傅里叶变换优化了哪个环节？是问题级别的优化。 
> 快速排序的时间复杂度：O($n\log {n}$)；快速排序是原位排序，不会占用额外内存。
> 
> - 为什么二分代码要用左闭右开区间？因为闭区间在判断空集时有弊端；而开区间在区间拼接时有弊端；因此半开半闭区间有优势——因此对于二分代码，要用左闭右开区间
> - 动态规划：在给定约束条件下找到最优解，在问题可分解为彼此独立且离散的子问题时，可使用动态规划解决。每种动态规划解决方案都涉及网格，单元格中的值通常就是要优化的值，每个单元格都是一个子问题。

## 矩阵快速幂算法
通常用于解决斐波那契数列等递归关系问题，核心思想是将幂次分解为二进制形式，通过平方和乘法快速计算结果。（这个要能手写下来）
```cpp
Matrix A(1, 1, 1, 0);

Matrix QuickPow(Matrix A, int n){
    if(n==1) return A;
    Matrix half = QuickPow(A, n/2);
    if(n%2 == 1) return A * half * half;
    else return half * half;
}
```

## 记忆化搜索
原理：将函数调用的结果存储起来，适用于递归算法
```cpp
//计算斐波那契数列
int f(int n){
    if(a[n]>0)
        return a[n];
    if(n<=2)
        return 1;
    return a[n] = f(n-1)+f(n-2);

}
```

## 二分查找
原理：每次比较时，将搜索范围减半，直到找到元素或范围为空。
```cpp
//zjy的版本
  
const int maxn = 1e5+5;  
// 定义一个全局数组a，用于存储输入的整数  
int a[maxn];  
// 定义全局变量n和k，分别用于存储数组a的长度和需要达到的目标值  
int n, k;  
// 定义全局变量maxL，用于存储数组a中的最大值  
int maxL;  
  
// 定义函数cut，用于计算数组a中所有元素除以L后的和  
int cut(int L) {  
    int s = 0; // 初始化和s为0  
    for(int i = 0; i < n; i ++) { 
        s += a[i] / L; // 累加每个元素除以L的商  
    }  
    return s;  
}  
  
// 定义函数bs，用于通过二分查找找到满足cut(L) >= v的最小L值  
int bs(int v) {  
    int l = 1, r = maxL + 1; // 定义二分查找的左右边界  
    while(l < r) { // 当左边界小于右边界时继续查找  
        int mid = l + (r-l)/2; // 计算中间值mid  
        if(cut(mid) >= v) { // 如果cut(mid)的值大于等于目标值v  
            l = mid+1; // 更新左边界为mid+1，继续向右查找  
        } else {  
            r = mid; // 否则更新右边界为mid，向左查找  
        }  
    }  
    return l - 1; // 返回最终查找到的最小L值（注意需要减去1，因为最后l会超出目标值）  
}  
  
int main() {  
    ios::sync_with_stdio(false); // 关闭C++标准库与C标准库的同步，加速输入输出  
    cin >> n >> k; 
    maxL = 0; // 初始化maxL为0  
    for(int i = 0; i < n; i ++) { 
        cin >> a[i];   
        maxL = max(a[i], maxL); // 更新maxL为当前元素和maxL中的较大值  
    }  
    cout << bs(k) << endl; // 调用bs函数，输出满足cut(L) >= k的最小L值  
    return 0; 
}
```
二分查找的写法很多，可以参考这道题
[搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)
>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。